# 操作系统
## 进程间通信
竞争条件 - 两个或者多个进程读写某些共享数据，最后结果取决于进程间的精确运行时序，称为竞争条件。  
解决竞争条件的方法 - 互斥锁，具体实现方式有以下几种：  
1. 屏蔽中断 - 当一个进程进入临界区后，屏蔽系统的所有中断，直到操作完成。这样就可以避免进程执行过程中被打断。缺点：可能导致系统终止，如果进程处理完后忘记开中断。  
2. 锁变量 - 定义一个01变量，0表示可以进入、1表示已被加锁。缺点：判断锁是否可用和加锁间并非原子操作，可能在进程a在判断锁可用之后和加锁之前被进程b中断，此时进程b看到的锁还是可用的，导致同时进入临界区。  
3. 严格轮换法 - 即自旋锁，通过一个变量记录哪个进程可以进入临界区，例如：当变量为0时，进程0可以进入临界区，此时进程1忙等待变量变为1,进程0离开临界区后将变量置为1。缺点：忙等待时，进程不做任何操作，浪费cpu时间，如果两个进程的非临界执行时间差距大，则非临界执行时间长的会成为瓶颈。  
```cpp 
//进程0：
while(TRUE){
	while(turn != 0);	//忙等待
	//临界区
	dosomething();
	turn = 1;
	//离开
}
//进程1：
while(TRUE){
	while(turn != 1);	//忙等待
	//临界区
	dosomething();
	turn = 0;
	//离开
}
```  
4. Peterson解法 - 不使用严格的轮询，增加进入期望数组。  
5. 信号量 - 将检查数值、修改变量以及可能发生的睡眠操作作为一个不可分割的操作，即原子操作，保证一个信号量操作开始后不会被其它进程打断。缺点：处理不当容易产生死锁。  
```cpp
//信号量实现生产者消费者模型
void producer(void){
	int item;
	while(TRUE){
		item = produce_item();		//产生新数据
		down(&empty);				//减少缓存区剩余空槽
		down(&mutex);				//进入临界区  p
		insert();					//将数据放进缓存区
		up(&mutex);					//离开临界区  v
		up(&full);					//增加待处理数据数量
	}
}

void consumer(void){
	int item;
	while(TRUE){
		down(&full);				//减少待处理数据数量
		down(&mutex);				//进入临界区  p
		item = remove();			//从缓存区取数据
		up(&mutex);					//离开临界区
		up(&empty);					//增加缓存区剩余空槽
		consume_item();				//处理数据
	}
}
``` 
5. 互斥量 - 只有0和1两种状态的信号量。  
```cpp 
class semaphore
{
 public:
     semaphore(int value = 1) :count(value) {}
 
     void wait()
     {
         unique_lock<mutex> lck(mtk);
         if (--count < 0)	//资源不足挂起线程
             cv.wait(lck);
     }
 
     void signal()
     {
         unique_lock<mutex> lck(mtk);
         if (++count <= 0)	//有线程挂起，唤醒一个
             cv.notify_one();
     }
 
 private:
     int count;
     mutex mtk;
     condition_variable cv;
};
``` 
6. 自旋锁使用注意 - 几个重要的特性：1、被自旋锁保护的临界区代码执行时不能进入休眠。2、被自旋锁保护的临界区代码执行时是不能被被其他中断中断。3、被自旋锁保护的临界区代码执行时，内核不能被抢占。从这几个特性可以归纳出一个共性：被自旋锁保护的临界区代码执行时，它不能因为任何原因放弃处理器。如果违反可能导致死锁。  

## 内存分区
1. MBR原理：Master Boot Record，主分区引导记录。MBR就保存在主引导扇区中。另外，这个扇区里还包含了硬盘分区表DPT（Disk Partition Table），和结束标志字（Magic number）。扇区总计512字节，MBR占446字节（0000H - 01BDH），DPT占据64个字节（01BEH - 01FDH），最后的magic number占2字节（01FEH – 01FFH）。  
在只分配64字节给DPT的情况下，每个分区项分别占用16个字节，因此只能记录四个分区信息；**能表示的最大扇区数为FF FF FF FFH**，因此可管理的最大空间=总扇区数 * 扇区大小(512byte)，也就是2TB。  
2. GPT原理：GPT分区全称为Globally Unique Identifier Partition Table，也叫做GUID分区表，它是UEFI 规范的一部分。  
优点：1、支持2TB以上的大硬盘; 2、每个磁盘的分区个数几乎没有限制(Windows系统最多只允许划分128个分区); 3、分区大小几乎没有限制。又是一个“几乎”。因为它用64位的整数表示扇区号，即18,446,744,073,709,551,616个扇区; 4、分区表自带备份。在磁盘的首尾部分分别保存了一份相同的分区表，其中一份被破坏后，可以通过另一份恢复; 5、循环冗余检验值针对关键数据结构而计算，提高了数据崩溃的检测几率; 6、虽然MBR提供1字节分区类型代码，但GPT使用一个16字节的全局唯一标识符（GUID）值来标识分区类型，这使分区类型更不容易冲突; 7、每个分区可以有一个名称(不同于卷标)。  
