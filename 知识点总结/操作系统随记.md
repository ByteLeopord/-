# 操作系统
## 进程间通信
竞争条件 - 两个或者多个进程读写某些共享数据，最后结果取决于进程间的精确运行时序，称为竞争条件。  
解决竞争条件的方法 - 互斥锁，具体实现方式有以下几种：  
1. 屏蔽中断 - 当一个进程进入临界区后，屏蔽系统的所有中断，直到操作完成。这样就可以避免进程执行过程中被打断。缺点：可能导致系统终止，如果进程处理完后忘记开中断。  
2. 锁变量 - 定义一个01变量，0表示可以进入、1表示已被加锁。缺点：判断锁是否可用和加锁间并非原子操作，可能在进程a在判断锁可用之后和加锁之前被进程b中断，此时进程b看到的锁还是可用的，导致同时进入临界区。  
3. 严格轮换法 - 即自旋锁，通过一个变量记录哪个进程可以进入临界区，例如：当变量为0时，进程0可以进入临界区，此时进程1忙等待变量变为1,进程0离开临界区后将变量置为1。缺点：忙等待时，进程不做任何操作，浪费cpu时间。  
```cpp 
//进程0：
while(TRUE){
	while(turn != 0);	//忙等待
	//临界区
	dosomething();
	turn = 1;
	//离开
}
//进程1：
while(TURE){
	while(turn != 1);	//忙等待
	//临界区
	dosomething();
	turn = 0;
	//离开
}
```  
4. 信号量 - 将检查数值、修改变量以及可能发生的睡眠操作作为一个不可分割的操作，即原子操作，保证一个信号量操作开始后不会被其它进程打断。缺点：处理不当容易产生死锁。  
```cpp
//信号量实现生产者消费者模型
void producer(void){
	int item;
	while(TRUE){
		item = produce_item();		//产生新数据
		down(&empty);				//减少缓存区剩余空槽
		down(&mutex);				//进入临界区  p
		insert();					//将数据放进缓存区
		up(&mutex);					//离开临界区  v
		up(&full);					//增加待处理数据数量
	}
}

void consumer(void){
	int item;
	while(TRUE){
		down(&full);				//减少待处理数据数量
		down(&mutex);				//进入临界区  p
		item = remove();			//从缓存区取数据
		up(&mutex);					//离开临界区
		up(&empty);					//增加缓存区剩余空槽
		consume_item();				//处理数据
	}
}
``` 
5. 互斥量 - 只有0和1两种状态的信号量。  
