# 计算机网络

## OSI层次模型

访问一个网站经历的过程：
浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS服务器是基于UDP的，因此会用到UDP协议。得到IP地址后，浏览器就要与服务器建立一个http连接，因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。以太网协议需要知道目的IP地址的物理地址，有需要ARP协议。

### 应用层

- 作用

	- 提供不同网络服务的用户接口

- 协议

	- HTTP协议 80

	  无状态：每个HTTP请求之间没有上下文关系；
	  cookie：保留客户信息

		- 请求

			- 头格式

				- 请求行：方法 目标资源URL 版本号
				- 子主题 2

			- 方法

				- GET

					- 申请获得资源，不对服务器产生影响

				- HEAD
				- POST

					- 向服务器提交数据，多次连续传输会对服务器产生影响（创建新资源、修改原有资源）

				- PUT

					- 多次连续发送具有完全相同的效果

				- OPTION

					- 一般用于获取服务器支持的方法

				- TRACE

		- 应答

			- 头格式
			- 状态码

				- 1XX：信息

					- 100

				- 2XX：成功

					- 200：服务器成功返回请求信息

				- 3XX：重定向

					- 301：永久重定向
					- 302：暂时重定向
					- 307：重定向中保持原来的请求数据
（POST请求的重定向如果服务请返回状态码不是307，则下一个请求会变成GET）

				- 4XX：客户端错误

					- 403：服务器拒绝提供服务
					- 404：请求地址不存在

				- 5XX：服务端错误

					- 500：服务器暂时不可用

		- 版本与区别

			- HTTP1.0
			- HTTP1.1

				- 1. 长连接：默认使用keep alive参数告知服务器建立长连接
				- 2. 节约带宽：只发送header信息，如果服务器认为客户端有权限请求就返回100，否则返回401；只有收到100才body
				- 3. HOST域：多个虚拟站点共享一个ip和端口
				- 4. 建立多个TCP连接，实现并行加载
				- 5. 缓存处理，实现文件的断点续传

			- HTTP2.0

				- 1. 多路复用：浏览器可以并发处理多个请求，在一个连接中发送多个请求接收多个响应，添加了响应的优先级
				- 2. 首部压缩：对首部信息进行了压缩，是数据体积变小
				- 3. 服务器推送：对客户端的一个请求帧发送多个响应，如果有更新将资源先推送到客户端，等客户端需要时可以直接从本地加载
				- 4. 二进制分帧：将header和body部分分开封装

	- HTTPS 443

		- 在HTTP基础上增加SSL加密，添加了加密的握手环节：确认服务器身份->确定加密算法->确认客户端身份->使用公钥加密传输，自身的私钥解密

			- ssl握手具体过程：
1. 客户端发起https连接请求，并将自身支持的加密算法发送到服务器
2. 服务器响应请求，从加密算法中选择一种告诉客户端
3. 服务器将自己的数字证书发送给客户端(里面含有服务器的公钥)
4. 服务器发送协商结束报文
5. 客户端用认证机构(CA)的公钥解密数字证书，确认服务器的身份并取得其公钥，采用协商的加密算法(产生对称加密的密钥)并用公钥加密传输给服务器
6. 客户端告诉服务器以后使用此共享密钥进行加密传输
7. 服务端使用私钥对含有共享密钥的密文进行解密，获得共享密钥
8. 服务器和客户端开始进行加密传输

	- FTP

		- 文件传输

	- SMTP、POP3

		- 邮箱通信

	- DNS

		- UDP传输
		- 查询方式

			- 迭代查询

				- 本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址
				- 本地DNS服务器与上级服务器之间

					- 特点：客户端发送请求，对方给出结果或给出可查询的下一个DNS服务器，客户端对该服务器再次发送请求

			- 递归查询

				- 客户端是递归查询，DNS服务器的每次迭代都会告诉客户端
				- 客户端与本地DNS服务器之间

					- 特点：客户端只发送一次请求，要求对方给出最终结果

### 表示层

- 作用

	- 提供对应用层数据的格式处理

- 协议

	- 加密解密、jpeg、gif、ascii等转换

### 会话层

- 作用

	- 建立端连接并提供访问验证和会话的管理

- 协议

	- 验证用户登录、断点续传
	- SMB：用于WIN传输

### 传输层

- 作用

	- 提供可靠的端到端服务，处理数据包的错误、乱序等问题，向高层屏蔽下层的通信细节

- 协议

	- TCP

		- 特点

			- 面向连接：通信双方需要先建立连接，即双方的内核都需要为连接分配资源
			- 字节流：区别于数据包传输，TCP收发的报文数量和应用程序执行的读写操作次数无关
			- 可靠传输：应答反馈、超时重传、序列号重组

		- TCP头部

			- 固定20byte + 可选40byte

	- UDP

		- 特点

			- 面向消息
			- 数据包传输

				- 通信两端的收发调用read write函数的次数相同

			- 不可靠传输

### 网络层

- 作用

	- 为数据传输创建逻辑链路，处理初步的数据报文问题，如分组和合并，使用逻辑IP地址

- 协议

	- IP
	- ICMP
	- RIP

		- 维护路由器从自己到目标网点的距离记录，没经过一个路由跳数加1，一般不能超过16跳

### 数据链路层

- 作用

	- 为通信实体间建立数据链路连接，使用原始MAC地址

- 协议

	- ARP

		- ip -> mac

			- 数据链层用mac地址作为通信目标，IP数据包准备封装成数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址。如果查到了，就将目标ip的mac地址封装到链路层数据包的包头；如果缓存中没有找到，会发起一个广播，所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单播的形式将自己的mac地址回复给请求的机器。

	- RARP

		- mac -> ip

### 物理层

- 作用

	- 提供比特流传输

- 协议

	- 有线、无线

## 分片

## 部分密码学

### 对称加密

### 非对称加密

### 数字证书

### 中间人问题

## TCP/IP协议

### 可靠性

- 应答反馈
- 序列号
- 超时重传

	- 重传定时器

- 流量控制

	- 滑动窗口

- 拥塞控制

	- 方法

		- 慢启动

			- 指数增长至慢启动门限

		- 拥塞避免

			- 线性增长至传输超时（或收到重复确认），认为拥塞发生

				- 传输超时->慢启动+拥塞避免
				- 重复确认->快重传+快恢复

		- 快速重传

			- 发送端连续收到3个重复的确认报文：慢启动门限为当前发送窗口的1/2，重传丢失报文

		- 快速恢复

			- 发送端每次收到一个重复确认，拥塞窗口+1，当收到新的确认，拥塞窗口立即设为慢启动门限

	- 原因

		- 防止拥塞死锁

### 三次握手、四次挥手

- 三次握手

	- 流程

		- 1）客户端发起连接请求，包含客户端的ISN1序列号；
2）服务端响应请求，包含服务端的ISN2序列号、返回的序列号ISN1+1；
3）客户端响应服务端的返回，包含返回的序列号ISN2+1。

	- 原因：防止已经失效的连接请求报文突然传到服务端导致服务端的资源浪费。

- 四次挥手

	- 流程

		- 1）客户端发起结束请求，包含序列号；
2）服务端响应结束请求；（客户端处在半关闭状态）
3）服务端发起结束请求，包含序列号；
4）客户端响应结束请求。

	- 原因：TCP是全双工通信

- 半关闭

	- 在close()前加入shutdown()，接收到对方的应答再调用close()

- 主动关闭

	- 发出req->FIN_WAIT_1、接收ack->FIN_WAIT_2、接收req->TIME_WAIT
	- TIME_WAIT原因

- 被动关闭

	- 接收req->CLOSE_WAIT、发送req->LAST_ACK

- 状态转移过程图：
服务器：LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK
客户端：CLOSE -> SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT(2ML)

  客户端发出FIN报文后处于FIN_WAIT_1状态，如果服务端返回结束请求的报文中添加了结束请求，则客户端直接进入TIME_WAIT状态
  
  特殊情况：同时打开和同时关闭

### 对应socket

- 服务器：socket() -> bind() -> listen() -> accept() -> read()/write() ->close()

  bind函数将套接字与 IP地址和端口号 进行了绑定，客户端可通过这个IP地址和端口号访问到这个套接字

- 客户端：socket() -> connect() -> read()/write() -> close()

  客户端在调用connect函数时，由操作系统给这个客户端分配IP和端口号，使用主机的IP、端口号随机

- 注意：客户端的connect()函数在服务器调用listen()后就推出阻塞状态，视为建立连接，而不需要等服务器调用accept()函数

### 计时器

- 重传计时器

	- 确认报文丢失，发送方重传

- 持续计时器

	- 接收窗口为0，TCP停止发送；但窗口变为非0的确认丢失，双方死锁；故当接受到0窗口回复启动计时，时间到了发送探测报文，让对方重新发送窗口大小报文

- 保活计时器

	- 建立连接，避免客户端长时间不发数据；到时间断开连接

- 时间等待计时器

	- TIME_WAIT2 报文段的寿命2倍

### 粘包问题

- 发送方的若干包数据到接收方时粘成了一包

### 糊涂窗口综合症

- 可用窗口大小一直为1，网络效率低
- 接收方等待一段时间再发送响应

*XMind - Trial Version*