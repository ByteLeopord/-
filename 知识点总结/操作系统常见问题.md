 # 操作系统
---
* linux常见操作  
  答：
    
* 进程与线程的区别和联系  
  答：进程是资源分配的单位、线程是CPU调度的单位；进程拥有一个完整的资源平台、线程只独享寄存器和栈空间；进程和线程都拥有就绪、执行、阻塞三种状态；线程可以减少并发执行的时间和空间开销-线程的创建和终止时间比进程的要短、线程间的切换时间比进程短、线程可以通过共享用户空间进行线程间通信而进程需要陷入内核。  
    
* 一个进程可以创建多少线程，和什么有关  
  答：一个操作系统一般能创建4096个进程，可以通过ulimit -u指令修改，因为pid_t是一个short类型的变量，理论上可以存在32768个进程；而一个进程可以创建多少个线程，由操作系统的位数和栈大小决定，如果是32位的系统，一个进程拥有4g内存空间，分配给用户3g，而每个线程需要独享1m或者10m的栈空间，所以最多创建3000后者300个线程。  
    
* 一个程序从开始运行到结束的完整过程（四个过程）  
  答：开始->阻塞->就绪<->运行->结束(或阻塞)。  
    
* 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）  
  答：进程通信-管道、fifo、信号量、共享内存、消息队列；线程通信-信号量、锁、条件变量；  
    
* 文件读写使用的系统调用  
  答：open() close() read() write()  
    
* 怎么回收线程  
  答:pthread_exit()-单个线程结束、pthread_join()-同一进程的其他线程阻塞等待线程的结束（调用pthread_exit）、pthread_cancel()-另一线程请求结束该线程。  
    
* 守护进程、僵尸进程和孤儿进程  
  答：守护进程-运行在后台，没有用户接口；僵尸进程-子进程先结束，父进程没有调用wait函数回收子进程，父进程结束后到被init进程接收之前的状态；孤儿进程-父进程提前结束，被init进程接收后的状态。  
    
* [处理僵尸进程的两种经典方法](https://www.cnblogs.com/scut-fm/archive/2013/10/29/3393686.html)
  
* 进程终止的几种方式  
  答：正常结束-从main函数返回、调用exit函数、最后一个线程结束；异常终止-abort函数、异常退出（超时、内存不足、越界访问、特权指令、保护错误等）、信号终止（ctrl+c）。    
    
* linux中异常和中断的区别  
  答：中断-与当前执行进程无关的、异步发生的、独立的外部事件，如：时钟中断、IO中断、内存错误；异常-当前正在执行进程所产生的的错误，如：。  
    
* 一般情况下在Linux/windows平台下栈空间的大小  
  答：1024KB或10MB   
    
*  五种IO模型  
  答：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO。  
    
* 程序从堆中动态分配内存时，虚拟内存上怎么操作的  
  答：根据内存分配算法分配合适的内存空间。如果该内存暂时没有被使用，只在虚拟内存中进行了记录，没有放入到物理内存中，而是在硬盘空间；当该内存被操作了，产生缺页中断将其调入到内存中。  
    
* 交换空间与虚拟内存的关系  
  答：交换空间-Linux 中的交换空间（Swap space）在物理内存被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。虚拟内存-虚拟内存是文件数据交叉链接的活动文件。虚拟内存使用的是硬盘的空间，为了解决运行进程太多内存不够的问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。  
    
* 堆和栈的区别；从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）  
  答：堆和栈在内存的位置不同、地址的增长方向不同、操作者不同；栈比较快，由操作系统控制，且没有搜索合适内存的步骤。  
    
* 内存泄漏和内存溢出  
  答：内存泄漏-申请的空间没有被释放；内存溢出-申请或者操作的空间超出允许范围。  
    
* 常见内存分配方式和错误  
  答：静态内存分配、栈上分配、堆上分配。常见错误-内存未分配成功却使用、内存分配成功未初始化即使用、操作越界、内存泄漏、操作已释放内存。  
    
* 堆内存和栈内存的区别  
  答：
    
* [可重入函数和可重入内核](https://blog.csdn.net/chj1234chj/article/details/78162443?locationNum=7&fps=1)  
  答：可重入函数的条件-不在函数内部使用静态变量或者全局变量、不返回静态变量或全局变量、只使用局部变量或者全局变量的拷贝来保护全局变量、如果调用全局变量必须使用互斥锁保护、不调用不可重入函数。  
    
* 操作系统动态内存分配的几种策略  
  答：首次适配、循环首次适配、最佳适配、最坏适配。  
    
* 内部碎片和外部碎片  
  答：内部碎片-已经被分配出去（属于具体的进程）却不能被利用的内存空间；占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。外部碎片-还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
    
* 系统调用进入内核态的过程  
  答：
    
* 内核态和用户态的区别  
  答：内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在0级特权级上时，就可以称之为运行在内核态。当发生系统调用、异常、中断时会从用户态陷入到内核态。 区别-处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。  
    
* 常见的进程调度算法以及linux的进程调度  
  答：1.先来先服务-按队列顺序处理、非抢占调度；优-有利于CPU繁忙的作业 缺-不利于IO繁忙的作业。2.短作业优先调度-有限给处理时间短的进程分配处理器，非抢占调度；优-提高系统吞吐量 缺-可能饿死长作业。3.时间片轮转调度-为进程周期分配时间片，适中抢占。4.优先权调度算法-为进程分配优先级，非抢占式：优先级高的运行完才可运行下一个进程，抢占式：优先级高的就绪进程抢占执行。5.高响应比调度-基于到来进程的等待时间增加进程的优先级（等待时间/服务时间）。6.多级反馈队列调度-维护有优先级的队列，优先级越高分配时间片越小，先顺序执行优先级高的队列中的进程。  
  linux常见进程调度-1、2、3、6。实时进程调度也基于上述的算法，且实时进程具有绝对的优先级。  
    
* 中断、陷阱、故障和终止  
  答：中断-异步发生，来自处理器外部IO设备的信号（区别于同步异常：执行一条指令的结果），它不是由任何一条专门的指令造成的。中断处理程序总是返回到当前指令的下一条指令。陷阱-同步异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。陷阱总返回到当前指令。故障-由错误引起，它可能被故常处理程序修正，如果修正成功，将返回到当前正在执行的指令，重新执行。否则处理程序返回到内核的abort历程，将终止故障程序，如缺页异常。终止-由不可恢复的知名错误造成的结果，处理程序将返回到内核中的abort例程，终止应用程序。  
    
* 内存对齐的规则和作用  
  答：针对结构体而言-1.对于结构的各个成员，第一个成员位于偏移为0的位置，以后每一个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数；2.在数据成员完毕各自对齐之后，结构(或联合)本身也要进行对齐，对齐将依照#pragma pack指定的数值和结构(或联合)最大数据成员长度中。比較小的那个进行。  
  作用-1.平台原因(移植原因)：不是全部的硬件平台都能访问随意地址上的随意数据的；某些硬件平台仅仅能在某些地址处取某些特定类型的数据，否则抛出硬件异常；2.性能原因：经过内存对齐后，CPU的内存访问速度大大提升，避免同一变量需要进行两次内存访问。  
    
* 页面置换算法  
  答：LRU-最近最久未使用 FIFO-先入先出 CLOCK-时钟置换算法 DCLOCK-二次机会时钟置换算法（区分读写） NFU-最不常用算法；局部页面置换和全局页面置换（定义一个工作集窗口，某个页面如果不在工作集窗口中，即使没有产生缺页中断也要被换出）。  
  [LRU算法](https://github.com/ByteLeopord/Algorithm/blob/master/LRU(%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0).cpp)  
    
- 实现一个LRU页置换算法（或者FIFO置换算法）  
  答：通过链表实现，最近使用的页面放在链表表头、每次页面置换则置换链表尾部页面。  
    
- 死锁的必要条件（怎么检测死锁，解决死锁问题）,银行家算法（死锁避免）  
  答：四个条件-不可抢占、互斥、请求与保持、环路等待；针对上述的四个条件-资源可被抢占、一个资源可以给多个进程提供服务、当请求资源不成功时进程释放已占有资源、资源按序分配；银行家算法-不安全状态指可能导致死锁状态，判断资源请求是否会导致不安全状态，是则推迟满足这个请求，否则拒绝请求。  
    
- 哲学家就餐，读者写者，生产者消费者（怎么加锁解锁，伪代码）  
  答：读者写者
``` 
/* 
mutex同步对readcnt的访问, w同步写者对缓冲区的访问, 而读者中只有第一个有P(&w),最后一个有V(&w)，即非第一个读者进 入时不会减w，也就不会导致进入禁止区，任意进入；一旦第一个读者 进入，w变成0，只有读者离开，写者才能写，如果一直有读者进入，一直w都是0，写者就必须一直等待
*/  
int reader(int serverfd, char *uri) {
    int hit= 0;
    P(&mutex);
    readcnt++;
    if (readcnt == 1) {
        P(&w);
    }
    V(&mutex);

    for (int i = 0; i < 10; ++i) {
        if (!strcmp(cache.cache_lines[i].id, uri)) {
            Rio_writen(serverfd, cache.cache_lines[i].object, MAX_OBJECT_SIZE);
            hit = 1;
            break;
        }
    }
    P(&mutex);
    readcnt--;
    if (readcnt == 0) {
        V(&w);
    }
    V(&mutex);
    return hit;
}  
void writer(char *uri, char *buf) {
    P(&w);
    strcpy(cache.cache_lines[cache.resident_cnt].id, uri);
    strcpy(cache.cache_lines[cache.resident_cnt].object, buf);
    ++cache.resident_cnt;
    V(&w);
}
 ``` 
    
- 海量数据的bitmap使用原理
- 布隆过滤器原理与优点
- 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题

# LINUX
---
* Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）

* 文件系统的理解（EXT4，XFS，BTRFS）

* 文件处理grep,awk,sed这三个命令必知必会

* IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？

* Epoll的ET模式和LT模式（ET的非阻塞）

* 查询进程占用CPU的命令（注意要了解到used，buf，cache代表意义）

* linux的其他常见命令（kill，find，cp等等）

* shell脚本用法

* 硬连接和软连接的区别

* 文件权限怎么看（rwx）

* 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变

* Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令
